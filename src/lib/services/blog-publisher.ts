/**
 * Blog Publisher Service
 * Orchestrates the entire blog publishing workflow
 */

import fs from 'fs/promises';
import path from 'path';
import { BlogInput, convertJsonToMarkdown, generateSlug } from './blog-converter';
import { GitService } from './git-service';
import { GitHubService } from './github-service';

export interface PublishOptions {
  reviewers?: string[];
  labels?: string[];
}

export interface PublishResult {
  success: boolean;
  message: string;
  slug?: string;
  branchName?: string;
  prUrl?: string;
  prNumber?: number;
  merged?: boolean;
  mergeSha?: string;
  error?: string;
}

export class BlogPublisher {
  private gitService: GitService;
  private githubService: GitHubService;
  private contentDir: string;

  constructor(
    githubToken: string,
    githubOwner: string,
    githubRepo: string,
    contentDir?: string
  ) {
    this.gitService = new GitService();
    this.githubService = new GitHubService(githubToken, githubOwner, githubRepo);
    this.contentDir = contentDir || path.join(process.cwd(), 'content', 'posts');
  }

  /**
   * Publishes a single blog post
   */
  async publishBlog(
    blog: BlogInput,
    options?: PublishOptions
  ): Promise<PublishResult> {
    try {
      // Generate slug from title
      const slug = generateSlug(blog.title);
      const fileName = `${slug}.md`;
      const filePath = path.join(this.contentDir, fileName);

      // Convert JSON to Markdown
      const markdownContent = convertJsonToMarkdown(blog);

      // Write the markdown file
      await fs.writeFile(filePath, markdownContent, 'utf-8');

      // Create branch name
      const branchName = `blog/${slug}-${Date.now()}`;

      // Git operations: create branch, commit, and push
      await this.gitService.createCommitAndPush(
        branchName,
        [filePath],
        `feat: Add new blog post "${blog.title}"`
      );

      // Create Pull Request
      const pr = await this.githubService.createPullRequest({
        title: `üìù New Blog Post: ${blog.title}`,
        body: this.generatePRBody(blog, slug),
        head: branchName,
        base: 'main',
      });

      // Add labels if provided
      if (options?.labels && options.labels.length > 0) {
        await this.githubService.addLabels(pr.number, options.labels);
      }

      // Add reviewers if provided
      if (options?.reviewers && options.reviewers.length > 0) {
        await this.githubService.addReviewers(pr.number, options.reviewers);
      }

      return {
        success: true,
        message: 'Blog post published successfully',
        slug,
        branchName,
        prUrl: pr.url,
        prNumber: pr.number,
      };
    } catch (error: any) {
      return {
        success: false,
        message: 'Failed to publish blog post',
        error: error.message,
      };
    }
  }

  /**
   * Publishes multiple blog posts
   */
  async publishMultipleBlogs(
    blogs: BlogInput[],
    options?: PublishOptions
  ): Promise<PublishResult[]> {
    const results: PublishResult[] = [];

    for (const blog of blogs) {
      const result = await this.publishBlog(blog, options);
      results.push(result);
    }

    return results;
  }

  /**
   * Generates the Pull Request body
   */
  private generatePRBody(blog: BlogInput, slug: string): string {
    return `
## üìù New Blog Post

**Title:** ${blog.title}  
**Author:** ${blog.author}  
**Date:** ${blog.date}  
**Slug:** ${slug}  
**Published:** ${blog.published ?? true}

### Description
${blog.description}

### Preview
This PR adds a new blog post to the content collection. The post will be available at \`/blog/${slug}\` once merged.

---
*This PR was automatically generated by the Blog Publishing System*
    `.trim();
  }

  /**
   * Validates that the content directory exists
   */
  async ensureContentDirectory(): Promise<void> {
    try {
      await fs.access(this.contentDir);
    } catch {
      await fs.mkdir(this.contentDir, { recursive: true });
    }
  }
}

